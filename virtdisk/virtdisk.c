/*
 * Copyright 2010 Primoz Beltram
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 * $Id$
 */

#include <string.h>

#include <shared/debug.h>

#include "virtdisk.h"

//------------------------------------------------------------------------------
/**
 * MBR with one FAT12 partition.
 * See http://en.wikipedia.org/wiki/Master_boot_record
 */
const char g_MBRSector[BLOCKSIZE] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x000
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x010
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x020
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x030
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x040
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x050
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x060
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x070
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x080
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x090
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0A0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0B0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0C0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0D0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0E0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0F0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x100
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x110
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x120
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x130
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x140
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x150
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x160
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x170
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x180
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x190
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1A0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x22, 0x93, 0x02, 0x00, 0x00, 0x00, 0x01, // 0x1B0
    0x01, 0x00, 0x01, 0x01, 0x3f, 0x0f, 0x3f, 0x00, 0x00, 0x00, 0xa1, 0x07, 0x00, 0x00, 0x00, 0x00, // 0x1C0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1D0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1E0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa  // 0x1F0
};
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/** First partition sector LBA, set from MBR partition record. */
unsigned int g_p1first_sect = 0;
/** Last partition sector LBA, calculated from MBR partition record data. */
unsigned int g_p1last_sect = 0;
/** Number of partition sectors, set from MBR partition record data. */
unsigned int g_p1nof_sect = 0;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
int diskInitialize(unsigned char disk __attribute__ ((unused)))
{

    // NOTE: Stored in Little-Endian byte coding.
    g_p1first_sect = g_MBRSector[0x1C6] + (g_MBRSector[0x1C7] << 8) +
            (g_MBRSector[0x1C8] << 16) + (g_MBRSector[0x1C9] << 24);
    g_p1nof_sect = g_MBRSector[0x1CA] + (g_MBRSector[0x1CB] << 8) +
                    (g_MBRSector[0x1CC] << 16) + (g_MBRSector[0x1CD] << 24);
    g_p1last_sect = g_p1first_sect + g_p1nof_sect - 1;

    return TRUE;
}
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
int diskRead(unsigned char disk __attribute__ ((unused)), unsigned char *buff,
        unsigned int sector, unsigned char count)
{
    int ret = TRUE;

//    DBG_WRITE_STR("diskRead");
//    DBG_WRITE_INT(sector);

    if (count != 1)
    {
        return FALSE;
    }

    if (sector == 0)
    {
        memcpy(buff, g_MBRSector, BLOCKSIZE);
    }
    else if ((sector >= g_p1first_sect) && (sector <= g_p1last_sect))
    {
        // Handle requests for file system on 1st partition.
        ret = fsRead(buff, sector - g_p1first_sect, g_p1nof_sect,
                g_MBRSector[0x1C2]);
    }
    else
    {
        memset(buff, 0, BLOCKSIZE);
    }

    return ret;
}
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
int diskWrite(unsigned char disk __attribute__ ((unused)),
        const unsigned char *buff, unsigned int sector, unsigned char count)
{
    int ret = TRUE;

//    DBG_WRITE_STR("diskWrite");
//    DBG_WRITE_INT(sector);

    if (count != 1)
    {
        return FALSE;
    }

    if ((sector >= g_p1first_sect) && (sector <= g_p1last_sect))
    {
        // Handle requests for file system on 1st partition.
        ret = fsWrite(buff, sector - g_p1first_sect, g_p1nof_sect,
                g_MBRSector[0x1C2]);
    }

    return ret;
}
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
int diskIoctl(unsigned char disk __attribute__ ((unused)) , unsigned char ctrl,
        void *buff)
{
    int ret = FALSE;

    DBG_WRITE_STR("diskIoctl");
    DBG_WRITE_BYTE(ctrl);

    switch (ctrl) {
        case IOCTL_GET_SECTOR_COUNT:
        {
            // Heads*Sectors*Cylinders
            *(unsigned int *) buff = 2*63*16;
            ret = TRUE;
        }
        break;

        case IOCTL_GET_SECTOR_SIZE:
        {
            *(unsigned short *) buff = BLOCKSIZE;
            ret = TRUE;
        }
        break;

        default:
            ret = FALSE;
    }

    return ret;
}
//------------------------------------------------------------------------------
